### 0. Model migrate, DB 반영

* accounts > models.py

  ```python
  from django.db import models
  from django.conf import settings
  from django.contrib.auth.models import AbstractUser
  
  # Create your models here.
  class User(AbstractUser):
      subscribers = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='subscribe')
      
      def __str__(self):
          return f'{self.pk}: {self.username}'
  
  class Profile(models.Model):
      user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
      nickname = models.CharField(max_length=30)
      introduction = models.TextField()
      point = models.IntegerField()
  ```

* moview > models.py

  ```python
  from django.db import models
  from django.urls import reverse
  from django.conf import settings
  
  # Create your models here.
  class Genre(models.Model):
      name = models.CharField(max_length=20)
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_genres', blank=True)
      def __str__(self):
          return f'Genre{self.pk}: {self.name}'
      
  class Cast(models.Model):
      name = models.CharField(max_length=50)
      profile_path = models.TextField()
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_casts', blank=True)
      def __str__(self):
          return f'Cast{self.pk}: {self.name}'
      
  class Director(models.Model):
      name = models.CharField(max_length=50)
      profile_path = models.TextField()
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_directors', blank=True)
      def __str__(self):
          return f'Director{self.pk}: {self.name}'
          
  class Movie(models.Model):
      adult = models.BooleanField()
      original_language = models.CharField(max_length=20)
      original_title = models.TextField()
      overview = models.TextField(blank=True)
      release_date = models.CharField(max_length=30)
      revenue = models.IntegerField()
      runtime = models.IntegerField()
      tagline = models.TextField(blank=True)
      title = models.TextField()
      genres = models.ManyToManyField(Genre, related_name='movies')
      casts = models.ManyToManyField(Cast, related_name='movies')
      role_data = models.TextField()
      poster_path = models.TextField()
      director = models.ForeignKey(Director, on_delete=models.PROTECT)
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_movies', blank=True)
      def __str__(self):
          return f'Movie{self.pk}: {self.title}'
          
  class Review(models.Model):
      title = models.CharField(max_length=30)
      content = models.TextField()
      score = models.IntegerField()
      movie = models.ForeignKey(Movie, on_delete=models.PROTECT)
      created_at = models.DateTimeField(auto_now_add=True)
      updated_at = models.DateTimeField(auto_now=True)
      user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_reviews', blank=True)
      def __str__(self):
          return f'Review{self.pk}: {self.title}'
      
  class Comment(models.Model):
      content = models.TextField()
      created_at = models.DateTimeField(auto_now_add=True)
      updated_at = models.DateTimeField(auto_now=True)
      user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
      like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_comments', blank=True)
      def __str__(self):
          return f'Comment{self.pk}: {self.content}'
  ```

* makedb.py

  ```python
  import requests
  import json, csv
  
  # key
  moviedb_key = "893975ab9d270ba1a8a8c1b31e213386"
  
  # keys
  keys = ['adult', 'original_language', 'original_title', 'overview',
                  'release_date', 'revenue', 'runtime', 'tagline', 'title', 
                  'genres', 'casts', 'role_data', 'director', 'poster_path']
  movies = []
  casts = []
  directors = []
  
  # 배우, 감독은 후에 파일 조작으로 중복 제거
  # 장르는 따로 받아와서 한 번에 생성
  
  for i in range(1, 6):
      url = f"https://api.themoviedb.org/3/movie/popular?api_key={moviedb_key}&language=ko-KR&page={i}"
      response = requests.get(url).json()
      lists = response['results']
      for movie in lists:
          detail_url = f"https://api.themoviedb.org/3/movie/{movie['id']}?api_key={moviedb_key}&language=ko-KR"
          movie_info = requests.get(detail_url).json()
          
          fields = {}
          for key in keys[:-5]:
              fields[key] = movie_info[key]
          for key in keys[-5: -2]:
              fields[key] = []
          fields['director'] = "-"
          fields['like_users'] = []
          if movie_info['poster_path']:
              poster_path = "https://image.tmdb.org/t/p/w600_and_h900_bestv2/" + movie_info['poster_path']
          else:
              poster_path = ""
          fields['poster_path'] = poster_path
          
          # genres
          tmp = []
          for genre in movie_info['genres']:
              tmp.append(genre['id'])
          fields['genres'] = tmp
              
          # director, casts
          credit_url = f"https://api.themoviedb.org/3/movie/{movie['id']}/credits?api_key={moviedb_key}"
          response = requests.get(credit_url).json()
          casts_p = response['cast'][:5]
          crews = response['crew']
          director = ''
          for crew in crews:
              if crew["job"] == "Director":
                  fields["director"] = crew["id"]
                  if crew['profile_path']:
                      profile_path = "https://image.tmdb.org/t/p/w600_and_h900_bestv2/" + crew['profile_path']
                  else:
                      profile_path = ""
                  directors.append({"model": "movies.director", "pk": crew["id"], "fields": {"name": crew["name"], "profile_path":profile_path, "like_users": []}})
                  break
          tmp = []
          for cast in casts_p:
              if cast['profile_path']:
                  profile_path = "https://image.tmdb.org/t/p/w600_and_h900_bestv2/" + cast['profile_path']
              else:
                  profile_path = ""
              casts.append({"model": "movies.cast", "pk": cast["id"], "fields":{"name": cast['name'], "profile_path": profile_path, "like_users": []}})
              tmp.append(cast['id'])
          fields['casts'] = tmp
          fields['role_data'] = casts_p
          
          movie = {"model": "movies.movie", "pk": movie_info["id"], "fields": fields}
          movies.append(movie)
          
          # 최초 쓰기
          with open('casts0.json', 'w', encoding='utf-8') as f:
              json.dump(casts, f, ensure_ascii=False, indent="\t")
          with open('directors0.json','w', encoding='utf-8') as f:
              json.dump(directors, f, ensure_ascii=False, indent="\t")
          with open('movies0.json','w', encoding='utf-8') as f:
              json.dump(movies, f, ensure_ascii=False, indent="\t")
  ```

* make_genredb.py

  ```python
  # https://api.themoviedb.org/3/genre/movie/list?api_key=4cfd64a4bb100569ac5eeaf4f3b49c9c&language=ko-KR
  
  import requests, json
  
  key = "4cfd64a4bb100569ac5eeaf4f3b49c9c"
  
  url = f"https://api.themoviedb.org/3/genre/movie/list?api_key={key}&language=ko-KR"
  
  response = requests.get(url).json()
  
  genres = response['genres']
  genres_a = []
  
  for genre in genres: 
      data = {"model": "movies.genre", "pk": genre["id"], "fields": {"name": genre["name"], "like_users": []}}
      genres_a.append(data)
      
  with open('genre.json', 'w', encoding='utf-8') as f:
      json.dump(genres_a, f, ensure_ascii=False, indent='\t')
  ```

* base.html

  * favicon : `05.13 3:30pm`
  * 

* Movie: poster_path, Cast: profile_path, Director: profile_path 추가 : `05.13 6pm`

* 평점 기본값 default_score로 넣어놓고 annotate한 score_avg가 없으면 대신 출력 : `05.14-05.15`

* db 다시

### 1. movies, review CRUD

* main page
  * review__score 내림차순으로 20개 정렬
  * +) 페이지 구현, 다 띄우기
* create review
  * +) 임시저장 기능 추가 예정
* detail page
* delete review : `05.13 6:30pm`
* update review : `05.13 6:45pm`
* 리뷰 작성 한 번만 가능하도록 수정 : `05.14 9:30am`

#### Detail Page

* 리뷰 R > collapse 이용

  * 기본 collapse 구현 : `05.13 7:20pm`

* 코멘트 CRUD > axios 이용, 페이지 이동 없이 처리 
  * CR (axios) : `05.13 7:50pm`
  * D (axios) : `05.14 11:00am`
  * U (axios)
    * 수정 버튼을 누르면 - 댓글 내용을 form > input 태그로 바꿔주고 이벤트리스너를 등록해서 수정 요청이 날아가게 해야지. get은 필요 없겠다. 애초에 get 요청이 날아오지 않으니 view에서는 포스트 요청만 처리
  * 코멘트 CRUD 완성 : `05.14 4:50pm`

* Detail Page, Main Page 꾸미기 (기초) : `05.15 10:45am`

* 등급 아이콘 - navbar, review에서 확인 가능 'fas fa-chess-ㅁ'

  * pawn(100) - rook(500) - knight(1000) - bishop(5000) - queen(10000) - king(50000)

  ```django
  <i class="fas fa-lg fa-chess-{% if user.profile.point >= 50000 %}king{% elif user.profile.point >= 10000 %}queen{% elif user.profile.point >= 5000 %}bishop{% elif user.profile.point >= 1000 %}knight{% elif user.profile.point >= 500 %}rook{% else %}pawn{% endif %}"></i>
  ```

* 댓글 수

  * 삭제 시 Eventlisner에서 innerText 변경 : `05.15 5:05pm`

* 댓글 작성 시 +10, 댓글 삭제 시 -10, 글 삭제 시 -100 넣기

### Like

* movie, director, cast 좋아요 : `05.15 2:00pm`
  * 내 영화 / 내 감독 / 내 배우 페이지에서 확인 가능
* 리뷰 좋아요, 코멘트 좋아요 : `05.15 3:20pm`

### Main

* 명예의 전당 (평점 top 10, 리뷰수 top 10)
* 내 장르 영화 추천 / 내 배우 영화 추천 / 내 감독 영화 추천
* 내가 구독한 사람이 좋아하는 영화

### Movie List

* left bar
  * genre filter
  * 평점 filter
* [django-bootstrap pagination](<https://github.com/jmcclell/django-bootstrap-pagination>)

